// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Buffer = require("bs-platform/lib/js/buffer.js");
var Format = require("bs-platform/lib/js/format.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function empty(param) {
  return /* Nil */0;
}

function is_empty(l) {
  var match = Curry._1(l, undefined);
  if (match) {
    return false;
  } else {
    return true;
  }
}

function $$return(x, param) {
  return /* Cons */{
          _0: x,
          _1: empty
        };
}

function cons(a, b, param) {
  return /* Cons */{
          _0: a,
          _1: b
        };
}

function head_exn(g) {
  var match = Curry._1(g, undefined);
  if (match) {
    return match._0;
  } else {
    return Pervasives.invalid_arg("OSeq.head_exn");
  }
}

function tail_exn(g) {
  var match = Curry._1(g, undefined);
  if (match) {
    return match._1;
  } else {
    return Pervasives.invalid_arg("OSeq.tail_exn");
  }
}

function $neg$neg(i, j, param) {
  if (i === j) {
    return /* Cons */{
            _0: i,
            _1: empty
          };
  }
  if (i < j) {
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: i,
            _1: (function (param) {
                return $neg$neg(partial_arg, j, param);
              })
          };
  }
  var partial_arg$1 = i - 1 | 0;
  return /* Cons */{
          _0: i,
          _1: (function (param) {
              return $neg$neg(partial_arg$1, j, param);
            })
        };
}

function $neg$neg$caret(i, j) {
  if (i === j) {
    return empty;
  }
  if (i < j) {
    var partial_arg = j - 1 | 0;
    return function (param) {
      return $neg$neg(i, partial_arg, param);
    };
  }
  var partial_arg$1 = j + 1 | 0;
  return function (param) {
    return $neg$neg(i, partial_arg$1, param);
  };
}

function map(f, l, param) {
  var match = Curry._1(l, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var tail = match._1;
  return /* Cons */{
          _0: Curry._1(f, match._0),
          _1: (function (param) {
              return map(f, tail, param);
            })
        };
}

function fold_map(f, acc, l, param) {
  var match = Curry._1(l, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var tl = match._1;
  var acc$1 = Curry._2(f, acc, match._0);
  return /* Cons */{
          _0: acc$1,
          _1: (function (param) {
              return fold_map(f, acc$1, tl, param);
            })
        };
}

function repeatedly(f, param) {
  return /* Cons */{
          _0: Curry._1(f, undefined),
          _1: (function (param) {
              return repeatedly(f, param);
            })
        };
}

function repeat(x, param) {
  return /* Cons */{
          _0: x,
          _1: (function (param) {
              return repeat(x, param);
            })
        };
}

function init(nOpt, f) {
  var n = nOpt !== undefined ? nOpt : Pervasives.max_int;
  var aux = function (r, param) {
    if (r >= n) {
      return /* Nil */0;
    }
    var x = Curry._1(f, r);
    var partial_arg = r + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function mapi(f, l) {
  var aux = function (f, l, i, param) {
    var match = Curry._1(l, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var tl = match._1;
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: Curry._2(f, i, match._0),
            _1: (function (param) {
                return aux(f, tl, partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(f, l, 0, param);
  };
}

function filter_map(f, _l, _param) {
  while(true) {
    var l = _l;
    var match = Curry._1(l, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var l$prime = match._1;
    var y = Curry._1(f, match._0);
    if (y !== undefined) {
      return /* Cons */{
              _0: Caml_option.valFromOption(y),
              _1: (function(l$prime){
              return function (param) {
                return filter_map(f, l$prime, param);
              }
              }(l$prime))
            };
    }
    _param = undefined;
    _l = l$prime;
    continue ;
  };
}

function filter(f, l) {
  var aux = function (f, _l, _param) {
    while(true) {
      var l = _l;
      var match = Curry._1(l, undefined);
      if (!match) {
        return /* Nil */0;
      }
      var tl = match._1;
      var x = match._0;
      if (Curry._1(f, x)) {
        return /* Cons */{
                _0: x,
                _1: (function(tl){
                return function (param) {
                  return aux(f, tl, param);
                }
                }(tl))
              };
      }
      _param = undefined;
      _l = tl;
      continue ;
    };
  };
  return function (param) {
    return aux(f, l, param);
  };
}

function append(a, b, param) {
  var match = Curry._1(a, undefined);
  if (!match) {
    return Curry._1(b, undefined);
  }
  var tl = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return append(tl, b, param);
            })
        };
}

function cycle(l, param) {
  return append(l, (function (param) {
                return cycle(l, param);
              }), undefined);
}

function iterate(x, f) {
  var aux = function (f, x, param) {
    var y = Curry._1(f, x);
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(f, y, param);
              })
          };
  };
  return function (param) {
    return aux(f, x, param);
  };
}

function fold(f, _acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    var match = Curry._1(l, undefined);
    if (!match) {
      return acc;
    }
    _l = match._1;
    _acc = Curry._2(f, acc, match._0);
    continue ;
  };
}

function foldi(f, acc, l) {
  var _i = 0;
  var _acc = acc;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc$1 = _acc;
    var i = _i;
    var match = Curry._1(l$1, undefined);
    if (!match) {
      return acc$1;
    }
    _l = match._1;
    _acc = Curry._3(f, i, acc$1, match._0);
    _i = i + 1 | 0;
    continue ;
  };
}

function reduce(f, g) {
  var match = Curry._1(g, undefined);
  if (match) {
    return fold(f, match._0, match._1);
  } else {
    return Pervasives.invalid_arg("reduce");
  }
}

function iter(f, _l) {
  while(true) {
    var l = _l;
    var match = Curry._1(l, undefined);
    if (!match) {
      return ;
    }
    Curry._1(f, match._0);
    _l = match._1;
    continue ;
  };
}

function iteri(f, l) {
  var _l = l;
  var _i = 0;
  while(true) {
    var i = _i;
    var l$1 = _l;
    var match = Curry._1(l$1, undefined);
    if (!match) {
      return ;
    }
    Curry._2(f, i, match._0);
    _i = i + 1 | 0;
    _l = match._1;
    continue ;
  };
}

function length(l) {
  return fold((function (acc, param) {
                return acc + 1 | 0;
              }), 0, l);
}

function unfold(f, acc, param) {
  var match = Curry._1(f, acc);
  if (match === undefined) {
    return /* Nil */0;
  }
  var acc$prime = match[1];
  return /* Cons */{
          _0: match[0],
          _1: (function (param) {
              return unfold(f, acc$prime, param);
            })
        };
}

function flat_map(f, l, param) {
  var match = Curry._1(l, undefined);
  if (match) {
    return fm_app_(f, Curry._1(f, match._0), match._1, undefined);
  } else {
    return /* Nil */0;
  }
}

function fm_app_(f, l, l$prime, param) {
  var match = Curry._1(l, undefined);
  if (!match) {
    return flat_map(f, l$prime, undefined);
  }
  var tl = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return fm_app_(f, tl, l$prime, param);
            })
        };
}

function take_nth(n, g) {
  var aux = function (_i, _g, _param) {
    while(true) {
      var g = _g;
      var i = _i;
      var match = Curry._1(g, undefined);
      if (!match) {
        return /* Nil */0;
      }
      var tl = match._1;
      if (i > 0) {
        _param = undefined;
        _g = tl;
        _i = i - 1 | 0;
        continue ;
      }
      if (i !== 0) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "OSeq.re",
                292,
                6
              ],
              Error: new Error()
            };
      }
      var partial_arg = n - 1 | 0;
      return /* Cons */{
              _0: match._0,
              _1: (function(tl,partial_arg){
              return function (param) {
                return aux(partial_arg, tl, param);
              }
              }(tl,partial_arg))
            };
    };
  };
  return function (param) {
    return aux(0, g, param);
  };
}

function nth(_i, _l) {
  while(true) {
    var l = _l;
    var i = _i;
    var match = Curry._1(l, undefined);
    if (match) {
      if (i === 0) {
        return match._0;
      }
      _l = match._1;
      _i = i - 1 | 0;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function mem(eq, x, gen) {
  var _gen = gen;
  while(true) {
    var gen$1 = _gen;
    var match = Curry._1(gen$1, undefined);
    if (!match) {
      return false;
    }
    if (Curry._2(eq, x, match._0)) {
      return true;
    }
    _gen = match._1;
    continue ;
  };
}

function for_all(p, _gen) {
  while(true) {
    var gen = _gen;
    var match = Curry._1(gen, undefined);
    if (!match) {
      return true;
    }
    if (!Curry._1(p, match._0)) {
      return false;
    }
    _gen = match._1;
    continue ;
  };
}

function exists(p, _gen) {
  while(true) {
    var gen = _gen;
    var match = Curry._1(gen, undefined);
    if (!match) {
      return false;
    }
    if (Curry._1(p, match._0)) {
      return true;
    }
    _gen = match._1;
    continue ;
  };
}

function min(lt, gen) {
  var match = Curry._1(gen, undefined);
  if (match) {
    return fold((function (min, x) {
                  if (Curry._2(lt, x, min)) {
                    return x;
                  } else {
                    return min;
                  }
                }), match._0, match._1);
  } else {
    return Pervasives.invalid_arg("min");
  }
}

function max(lt, gen) {
  var match = Curry._1(gen, undefined);
  if (match) {
    return fold((function (max, x) {
                  if (Curry._2(lt, max, x)) {
                    return x;
                  } else {
                    return max;
                  }
                }), match._0, match._1);
  } else {
    return Pervasives.invalid_arg("max");
  }
}

function equal(eq, gen1, gen2) {
  var _gen1 = gen1;
  var _gen2 = gen2;
  while(true) {
    var gen2$1 = _gen2;
    var gen1$1 = _gen1;
    var match = Curry._1(gen1$1, undefined);
    var match$1 = Curry._1(gen2$1, undefined);
    if (!match) {
      if (match$1) {
        return false;
      } else {
        return true;
      }
    }
    if (!match$1) {
      return false;
    }
    if (!Curry._2(eq, match._0, match$1._0)) {
      return false;
    }
    _gen2 = match$1._1;
    _gen1 = match._1;
    continue ;
  };
}

function partition(p, gen) {
  return [
          filter(p, gen),
          filter((function (x) {
                  return !Curry._1(p, x);
                }), gen)
        ];
}

function zip_index(gen) {
  var aux = function (r, gen, param) {
    var match = Curry._1(gen, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var tl = match._1;
    var partial_arg = r + 1 | 0;
    return /* Cons */{
            _0: [
              r,
              match._0
            ],
            _1: (function (param) {
                return aux(partial_arg, tl, param);
              })
          };
  };
  return function (param) {
    return aux(0, gen, param);
  };
}

function map2(f, l1, l2, param) {
  var match = Curry._1(l1, undefined);
  var match$1 = Curry._1(l2, undefined);
  if (!match) {
    return /* Nil */0;
  }
  if (!match$1) {
    return /* Nil */0;
  }
  var l2$prime = match$1._1;
  var l1$prime = match._1;
  return /* Cons */{
          _0: Curry._2(f, match._0, match$1._0),
          _1: (function (param) {
              return map2(f, l1$prime, l2$prime, param);
            })
        };
}

function fold2(f, _acc, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var acc = _acc;
    var match = Curry._1(l1, undefined);
    var match$1 = Curry._1(l2, undefined);
    if (!match) {
      return acc;
    }
    if (!match$1) {
      return acc;
    }
    _l2 = match$1._1;
    _l1 = match._1;
    _acc = Curry._3(f, acc, match._0, match$1._0);
    continue ;
  };
}

function iter2(f, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var match = Curry._1(l1, undefined);
    var match$1 = Curry._1(l2, undefined);
    if (!match) {
      return ;
    }
    if (!match$1) {
      return ;
    }
    Curry._2(f, match._0, match$1._0);
    _l2 = match$1._1;
    _l1 = match._1;
    continue ;
  };
}

function for_all2(f, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var match = Curry._1(l1, undefined);
    var match$1 = Curry._1(l2, undefined);
    if (!match) {
      return true;
    }
    if (!match$1) {
      return true;
    }
    if (!Curry._2(f, match._0, match$1._0)) {
      return false;
    }
    _l2 = match$1._1;
    _l1 = match._1;
    continue ;
  };
}

function exists2(f, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var match = Curry._1(l1, undefined);
    var match$1 = Curry._1(l2, undefined);
    if (!match) {
      return false;
    }
    if (!match$1) {
      return false;
    }
    if (Curry._2(f, match._0, match$1._0)) {
      return true;
    }
    _l2 = match$1._1;
    _l1 = match._1;
    continue ;
  };
}

function zip(a, b, param) {
  var match = Curry._1(a, undefined);
  var match$1 = Curry._1(b, undefined);
  if (!match) {
    return /* Nil */0;
  }
  if (!match$1) {
    return /* Nil */0;
  }
  var b$prime = match$1._1;
  var a$prime = match._1;
  return /* Cons */{
          _0: [
            match._0,
            match$1._0
          ],
          _1: (function (param) {
              return zip(a$prime, b$prime, param);
            })
        };
}

function unzip(l) {
  var first = function (l, param) {
    var match = Curry._1(l, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var tl = match._1;
    return /* Cons */{
            _0: match._0[0],
            _1: (function (param) {
                return first(tl, param);
              })
          };
  };
  var second = function (l, param) {
    var match = Curry._1(l, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var tl = match._1;
    return /* Cons */{
            _0: match._0[1],
            _1: (function (param) {
                return second(tl, param);
              })
          };
  };
  return [
          (function (param) {
              return first(l, param);
            }),
          (function (param) {
              return second(l, param);
            })
        ];
}

function compare(cmp, gen1, gen2) {
  var _gen1 = gen1;
  var _gen2 = gen2;
  while(true) {
    var gen2$1 = _gen2;
    var gen1$1 = _gen1;
    var match = Curry._1(gen1$1, undefined);
    var match$1 = Curry._1(gen2$1, undefined);
    if (!match) {
      if (match$1) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!match$1) {
      return 1;
    }
    var c = Curry._2(cmp, match._0, match$1._0);
    if (c !== 0) {
      return c;
    }
    _gen2 = match$1._1;
    _gen1 = match._1;
    continue ;
  };
}

function find(p, _e) {
  while(true) {
    var e = _e;
    var match = Curry._1(e, undefined);
    if (!match) {
      return ;
    }
    var x = match._0;
    if (Curry._1(p, x)) {
      return Caml_option.some(x);
    }
    _e = match._1;
    continue ;
  };
}

function find_map(f, _e) {
  while(true) {
    var e = _e;
    var match = Curry._1(e, undefined);
    if (!match) {
      return ;
    }
    var res = Curry._1(f, match._0);
    if (res !== undefined) {
      return res;
    }
    _e = match._1;
    continue ;
  };
}

function sum(e) {
  return fold((function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), 0, e);
}

function interleave(a, b, param) {
  var match = Curry._1(a, undefined);
  if (!match) {
    return Curry._1(b, undefined);
  }
  var tail = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return interleave(b, tail, param);
            })
        };
}

function flat_map_interleave(f, a, param) {
  var match = Curry._1(a, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var tail = match._1;
  var y = Curry._1(f, match._0);
  return interleave(y, (function (param) {
                return flat_map_interleave(f, tail, param);
              }), undefined);
}

function app_interleave(f, a, param) {
  var match = Curry._1(f, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var fs = match._1;
  var f1 = match._0;
  return interleave((function (param) {
                return map(f1, a, param);
              }), (function (param) {
                return app_interleave(fs, a, param);
              }), undefined);
}

function flatten(l, param) {
  var match = Curry._1(l, undefined);
  if (match) {
    return flat_app_(match._0, match._1, undefined);
  } else {
    return /* Nil */0;
  }
}

function flat_app_(l, l$prime, param) {
  var match = Curry._1(l, undefined);
  if (!match) {
    return flatten(l$prime, undefined);
  }
  var tl = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return flat_app_(tl, l$prime, param);
            })
        };
}

function take(n, l, param) {
  if (n === 0) {
    return /* Nil */0;
  }
  var match = Curry._1(l, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var l$prime = match._1;
  var partial_arg = n - 1 | 0;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return take(partial_arg, l$prime, param);
            })
        };
}

function take_while(p, l, param) {
  var match = Curry._1(l, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var l$prime = match._1;
  var x = match._0;
  if (Curry._1(p, x)) {
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return take_while(p, l$prime, param);
              })
          };
  } else {
    return /* Nil */0;
  }
}

function drop(_n, _l, _param) {
  while(true) {
    var l = _l;
    var n = _n;
    var l$prime = Curry._1(l, undefined);
    if (n === 0) {
      return l$prime;
    }
    if (!l$prime) {
      return /* Nil */0;
    }
    _param = undefined;
    _l = l$prime._1;
    _n = n - 1 | 0;
    continue ;
  };
}

function drop_while(p, _l, _param) {
  while(true) {
    var l = _l;
    var res = Curry._1(l, undefined);
    if (!res) {
      return /* Nil */0;
    }
    if (!Curry._1(p, res._0)) {
      return res;
    }
    _param = undefined;
    _l = res._1;
    continue ;
  };
}

function fold_while(f, _acc, _gen) {
  while(true) {
    var gen = _gen;
    var acc = _acc;
    var match = Curry._1(gen, undefined);
    if (!match) {
      return acc;
    }
    var match$1 = Curry._2(f, acc, match._0);
    var acc$1 = match$1[0];
    if (match$1[1] === "Stop") {
      return acc$1;
    }
    _gen = match._1;
    _acc = acc$1;
    continue ;
  };
}

function scan(f, acc, g) {
  var aux = function (f, acc, g, param) {
    var match = Curry._1(g, undefined);
    if (!match) {
      return /* Cons */{
              _0: acc,
              _1: empty
            };
    }
    var tl = match._1;
    var acc$prime = Curry._2(f, acc, match._0);
    return /* Cons */{
            _0: acc,
            _1: (function (param) {
                return aux(f, acc$prime, tl, param);
              })
          };
  };
  return function (param) {
    return aux(f, acc, g, param);
  };
}

function unfold_scan(f, acc, g) {
  var aux = function (f, acc, g, param) {
    var match = Curry._1(g, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var tl = match._1;
    var match$1 = Curry._2(f, acc, match._0);
    var acc$1 = match$1[0];
    return /* Cons */{
            _0: match$1[1],
            _1: (function (param) {
                return aux(f, acc$1, tl, param);
              })
          };
  };
  return function (param) {
    return aux(f, acc, g, param);
  };
}

function product_with(f, l1, l2) {
  var next_left = function (l1, l2, param) {
    var match = Curry._1(l1, undefined);
    if (match) {
      return append_all(match._1, l2, match._0, l2, undefined);
    } else {
      return /* Nil */0;
    }
  };
  var append_all = function (tl1, l2_init, x1, l2, param) {
    var match = Curry._1(l2, undefined);
    if (!match) {
      return next_left(tl1, l2_init, undefined);
    }
    var tl2 = match._1;
    return /* Cons */{
            _0: Curry._2(f, x1, match._0),
            _1: (function (param) {
                return append_all(tl1, l2_init, x1, tl2, param);
              })
          };
  };
  return function (param) {
    return next_left(l1, l2, param);
  };
}

function product(l1, l2) {
  return product_with((function (x, y) {
                return [
                        x,
                        y
                      ];
              }), l1, l2);
}

function app(fs, xs) {
  return product_with((function (f, x) {
                return Curry._1(f, x);
              }), fs, xs);
}

function $great$great$eq(xs, f) {
  return function (param) {
    return flat_map(f, xs, param);
  };
}

function $great$pipe$eq(xs, f) {
  return function (param) {
    return map(f, xs, param);
  };
}

function $great$great$pipe(xs, f) {
  return function (param) {
    return map(f, xs, param);
  };
}

function product3(l1, l2, l3) {
  return app(app(app((function (param) {
                        return /* Cons */{
                                _0: (function (x1, x2, x3) {
                                    return [
                                            x1,
                                            x2,
                                            x3
                                          ];
                                  }),
                                _1: empty
                              };
                      }), l1), l2), l3);
}

function product4(l1, l2, l3, l4) {
  return app(app(app(app((function (param) {
                            return /* Cons */{
                                    _0: (function (x1, x2, x3, x4) {
                                        return [
                                                x1,
                                                x2,
                                                x3,
                                                x4
                                              ];
                                      }),
                                    _1: empty
                                  };
                          }), l1), l2), l3), l4);
}

function product5(l1, l2, l3, l4, l5) {
  return app(app(app(app(app((function (param) {
                                return /* Cons */{
                                        _0: (function (x1, x2, x3, x4, x5) {
                                            return [
                                                    x1,
                                                    x2,
                                                    x3,
                                                    x4,
                                                    x5
                                                  ];
                                          }),
                                        _1: empty
                                      };
                              }), l1), l2), l3), l4), l5);
}

function product6(l1, l2, l3, l4, l5, l6) {
  return app(app(app(app(app(app((function (param) {
                                    return /* Cons */{
                                            _0: (function (x1, x2, x3, x4, x5, x6) {
                                                return [
                                                        x1,
                                                        x2,
                                                        x3,
                                                        x4,
                                                        x5,
                                                        x6
                                                      ];
                                              }),
                                            _1: empty
                                          };
                                  }), l1), l2), l3), l4), l5), l6);
}

function product7(l1, l2, l3, l4, l5, l6, l7) {
  return app(app(app(app(app(app(app((function (param) {
                                        return /* Cons */{
                                                _0: (function (x1, x2, x3, x4, x5, x6, x7) {
                                                    return [
                                                            x1,
                                                            x2,
                                                            x3,
                                                            x4,
                                                            x5,
                                                            x6,
                                                            x7
                                                          ];
                                                  }),
                                                _1: empty
                                              };
                                      }), l1), l2), l3), l4), l5), l6), l7);
}

function cartesian_product(l, param) {
  var match = Curry._1(l, undefined);
  if (!match) {
    return /* Cons */{
            _0: /* [] */0,
            _1: empty
          };
  }
  var tail = match._1;
  var tail$1 = function (param) {
    return cartesian_product(tail, param);
  };
  return product_with((function (x, tl) {
                  return {
                          hd: x,
                          tl: tl
                        };
                }), match._0, tail$1)(undefined);
}

function map_product_l(f, l) {
  return function (param) {
    return cartesian_product((function (param) {
                  return map(f, l, param);
                }), param);
  };
}

function group(eq, l, param) {
  var match = Curry._1(l, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var l$prime = match._1;
  var x = match._0;
  var partial_arg = Curry._1(eq, x);
  var partial_arg$1 = function (param) {
    return take_while(partial_arg, l$prime, param);
  };
  var partial_arg$2 = Curry._1(eq, x);
  var partial_arg$3 = function (param) {
    return drop_while(partial_arg$2, l$prime, param);
  };
  return /* Cons */{
          _0: (function (param) {
              return /* Cons */{
                      _0: x,
                      _1: partial_arg$1
                    };
            }),
          _1: (function (param) {
              return group(eq, partial_arg$3, param);
            })
        };
}

function uniq_rec_(eq, prev, _l, _param) {
  while(true) {
    var l = _l;
    var match = Curry._1(l, undefined);
    if (!match) {
      return /* Nil */0;
    }
    if (prev !== undefined) {
      var l$prime = match._1;
      var x = match._0;
      if (Curry._2(eq, x, Caml_option.valFromOption(prev))) {
        _param = undefined;
        _l = l$prime;
        continue ;
      }
      var partial_arg = Caml_option.some(x);
      return /* Cons */{
              _0: x,
              _1: (function(l$prime,partial_arg){
              return function (param) {
                return uniq_rec_(eq, partial_arg, l$prime, param);
              }
              }(l$prime,partial_arg))
            };
    }
    var l$prime$1 = match._1;
    var x$1 = match._0;
    var partial_arg$1 = Caml_option.some(x$1);
    return /* Cons */{
            _0: x$1,
            _1: (function(l$prime$1,partial_arg$1){
            return function (param) {
              return uniq_rec_(eq, partial_arg$1, l$prime$1, param);
            }
            }(l$prime$1,partial_arg$1))
          };
  };
}

function uniq(eq, l) {
  return function (param) {
    return uniq_rec_(eq, undefined, l, param);
  };
}

function chunks(n, e) {
  var aux = function (e, param) {
    var match = Curry._1(e, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var a = Caml_array.caml_make_vect(n, match._0);
    var _i = 1;
    var _e = match._1;
    while(true) {
      var e$1 = _e;
      var i = _i;
      if (i === n) {
        return /* Cons */{
                _0: a,
                _1: (function(e$1){
                return function (param) {
                  return aux(e$1, param);
                }
                }(e$1))
              };
      }
      var match$1 = Curry._1(e$1, undefined);
      if (!match$1) {
        return /* Cons */{
                _0: $$Array.sub(a, 0, i),
                _1: empty
              };
      }
      Caml_array.set(a, i, match$1._0);
      _e = match$1._1;
      _i = i + 1 | 0;
      continue ;
    };
  };
  return function (param) {
    return aux(e, param);
  };
}

function intersperse(x, g) {
  var aux_with_sep = function (g, param) {
    var match = Curry._1(g, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var g$prime = match._1;
    var y = match._0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return /* Cons */{
                        _0: y,
                        _1: (function (param) {
                            return aux_with_sep(g$prime, param);
                          })
                      };
              })
          };
  };
  return function (param) {
    var match = Curry._1(g, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var g$1 = match._1;
    return /* Cons */{
            _0: match._0,
            _1: (function (param) {
                return aux_with_sep(g$1, param);
              })
          };
  };
}

function make_(hd, tl) {
  if (hd) {
    return {
            hd: hd,
            tl: tl
          };
  } else {
    return {
            hd: List.rev(tl),
            tl: /* [] */0
          };
  }
}

function list_is_empty(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function push(x, q) {
  return make_(q.hd, {
              hd: x,
              tl: q.tl
            });
}

function pop_exn(q) {
  var match = q.hd;
  if (match) {
    var q$prime = make_(match.tl, q.tl);
    return [
            match.hd,
            q$prime
          ];
  }
  if (!list_is_empty(q.tl)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "OSeq.re",
            907,
            6
          ],
          Error: new Error()
        };
  }
  return Pervasives.invalid_arg("F_queue.pop_exn");
}

function merge(gens) {
  var next = function (_q, _param) {
    while(true) {
      var q = _q;
      if (list_is_empty(q.hd)) {
        return /* Nil */0;
      }
      var match = pop_exn(q);
      var g = match[0];
      if (g.TAG === /* Merge_from */0) {
        return yield_from(g._0, match[1]);
      }
      var q$prime = match[1];
      var match$1 = Curry._1(g._0, undefined);
      if (match$1) {
        var q$prime$1 = push({
              TAG: /* Merge_start */1,
              _0: match$1._1
            }, q$prime);
        return yield_from(match$1._0, q$prime$1);
      }
      _param = undefined;
      _q = q$prime;
      continue ;
    };
  };
  var yield_from = function (g, q) {
    var match = Curry._1(g, undefined);
    if (!match) {
      return next(q, undefined);
    }
    var partial_arg = push({
          TAG: /* Merge_from */0,
          _0: match._1
        }, q);
    return /* Cons */{
            _0: match._0,
            _1: (function (param) {
                return next(partial_arg, param);
              })
          };
  };
  var partial_arg = push({
        TAG: /* Merge_start */1,
        _0: gens
      }, {
        hd: /* [] */0,
        tl: /* [] */0
      });
  return function (param) {
    return next(partial_arg, param);
  };
}

function intersection(cmp, gen1, gen2) {
  var next = function (_x1, _x2, _param) {
    while(true) {
      var x2 = _x2;
      var x1 = _x1;
      if (!x1) {
        return /* Nil */0;
      }
      if (!x2) {
        return /* Nil */0;
      }
      var tl2 = x2._1;
      var tl1 = x1._1;
      var y1 = x1._0;
      var c = Curry._2(cmp, y1, x2._0);
      if (c === 0) {
        return /* Cons */{
                _0: y1,
                _1: (function(tl1,tl2){
                return function (param) {
                  return next(Curry._1(tl1, undefined), Curry._1(tl2, undefined), undefined);
                }
                }(tl1,tl2))
              };
      }
      if (c < 0) {
        _param = undefined;
        _x1 = Curry._1(tl1, undefined);
        continue ;
      }
      _param = undefined;
      _x2 = Curry._1(tl2, undefined);
      continue ;
    };
  };
  return function (param) {
    return next(Curry._1(gen1, undefined), Curry._1(gen2, undefined), undefined);
  };
}

function zip_with(f, a, b, param) {
  var match = Curry._1(a, undefined);
  var match$1 = Curry._1(b, undefined);
  if (!match) {
    return /* Nil */0;
  }
  if (!match$1) {
    return /* Nil */0;
  }
  var tlb = match$1._1;
  var tla = match._1;
  return /* Cons */{
          _0: Curry._2(f, match._0, match$1._0),
          _1: (function (param) {
              return zip_with(f, tla, tlb, param);
            })
        };
}

function sorted_merge(cmp, gen1, gen2) {
  var next = function (x1, x2, param) {
    if (!x1) {
      if (x2) {
        return x2;
      } else {
        return /* Nil */0;
      }
    }
    if (!x2) {
      return x1;
    }
    var y2 = x2._0;
    var y1 = x1._0;
    if (Curry._2(cmp, y1, y2) <= 0) {
      var partial_arg = Curry._1(x1._1, undefined);
      return /* Cons */{
              _0: y1,
              _1: (function (param) {
                  return next(partial_arg, x2, param);
                })
            };
    }
    var partial_arg$1 = Curry._1(x2._1, undefined);
    return /* Cons */{
            _0: y2,
            _1: (function (param) {
                return next(x1, partial_arg$1, param);
              })
          };
  };
  return function (param) {
    return next(Curry._1(gen1, undefined), Curry._1(gen2, undefined), undefined);
  };
}

function round_robin(nOpt, gen) {
  var n = nOpt !== undefined ? nOpt : 2;
  var start = function (i) {
    if (i === n) {
      return /* [] */0;
    }
    var g = take_nth(n, (function (param) {
            return drop(i, gen, param);
          }));
    return {
            hd: g,
            tl: start(i + 1 | 0)
          };
  };
  return start(0);
}

function permutations(l) {
  var aux = function (n, l) {
    if (l) {
      var x = l.hd;
      var partial_arg = aux(n - 1 | 0, l.tl);
      return function (param) {
        return flat_map((function (tail) {
                      return insert_(x, /* [] */0, tail);
                    }), partial_arg, param);
      };
    }
    if (n !== 0) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "OSeq.re",
              1082,
              6
            ],
            Error: new Error()
          };
    }
    return function (param) {
      return /* Cons */{
              _0: /* [] */0,
              _1: empty
            };
    };
  };
  var insert_ = function (x, left, right) {
    if (right) {
      var partial_arg = insert_(x, {
            hd: right.hd,
            tl: left
          }, right.tl);
      var partial_arg$1 = List.rev_append(left, {
            hd: x,
            tl: right
          });
      return function (param) {
        return /* Cons */{
                _0: partial_arg$1,
                _1: partial_arg
              };
      };
    }
    var partial_arg$2 = List.rev({
          hd: x,
          tl: left
        });
    return function (param) {
      return /* Cons */{
              _0: partial_arg$2,
              _1: empty
            };
    };
  };
  return aux(List.length(l), l);
}

function combinations(n, g) {
  if (n < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "OSeq.re",
            1108,
            2
          ],
          Error: new Error()
        };
  }
  var make_state = function (n, l, param) {
    var match = Curry._1(l, undefined);
    if (n === 0) {
      return /* Cons */{
              _0: /* [] */0,
              _1: empty
            };
    }
    if (!match) {
      return /* Nil */0;
    }
    var tail = match._1;
    var partial_arg = n - 1 | 0;
    var m1 = function (param) {
      return make_state(partial_arg, tail, param);
    };
    var m2 = function (param) {
      return make_state(n, tail, param);
    };
    return add(match._0, m1, m2, undefined);
  };
  var add = function (x, m1, m2, param) {
    var match = Curry._1(m1, undefined);
    if (!match) {
      return Curry._1(m2, undefined);
    }
    var m1$prime = match._1;
    return /* Cons */{
            _0: {
              hd: x,
              tl: match._0
            },
            _1: (function (param) {
                return add(x, m1$prime, m2, param);
              })
          };
  };
  return function (param) {
    return make_state(n, g, param);
  };
}

function power_set(g) {
  var make_state = function (l, param) {
    if (!l) {
      return /* Cons */{
              _0: /* [] */0,
              _1: empty
            };
    }
    var tail = l.tl;
    var m = function (param) {
      return make_state(tail, param);
    };
    return add(l.hd, m, undefined);
  };
  var add = function (x, m, param) {
    var match = Curry._1(m, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var m$prime = match._1;
    var l = match._0;
    return /* Cons */{
            _0: {
              hd: x,
              tl: l
            },
            _1: (function (param) {
                return /* Cons */{
                        _0: l,
                        _1: (function (param) {
                            return add(x, m$prime, param);
                          })
                      };
              })
          };
  };
  var partial_arg = fold((function (acc, x) {
          return {
                  hd: x,
                  tl: acc
                };
        }), /* [] */0, g);
  return function (param) {
    return make_state(partial_arg, param);
  };
}

function to_rev_list_rec_(_acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    var match = Curry._1(l, undefined);
    if (!match) {
      return acc;
    }
    _l = match._1;
    _acc = {
      hd: match._0,
      tl: acc
    };
    continue ;
  };
}

function to_rev_list(l) {
  return to_rev_list_rec_(/* [] */0, l);
}

function to_list(l) {
  var direct = function (i, l) {
    var match = Curry._1(l, undefined);
    if (match) {
      if (i === 0) {
        return List.rev(to_rev_list_rec_(/* [] */0, l));
      } else {
        return {
                hd: match._0,
                tl: direct(i - 1 | 0, match._1)
              };
      }
    } else {
      return /* [] */0;
    }
  };
  return direct(200, l);
}

function of_list(l) {
  var aux = function (l, param) {
    if (!l) {
      return /* Nil */0;
    }
    var l$prime = l.tl;
    return /* Cons */{
            _0: l.hd,
            _1: (function (param) {
                return aux(l$prime, param);
              })
          };
  };
  return function (param) {
    return aux(l, param);
  };
}

function of_array(startOpt, len, a) {
  var start = startOpt !== undefined ? startOpt : 0;
  var len$1 = len !== undefined ? len : a.length - start | 0;
  var aux = function (a, i, param) {
    if (i === len$1) {
      return /* Nil */0;
    }
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: Caml_array.get(a, i),
            _1: (function (param) {
                return aux(a, partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(a, start, param);
  };
}

function to_array(l) {
  var match = Curry._1(l, undefined);
  if (!match) {
    return [];
  }
  var n = length(l);
  var a = Caml_array.caml_make_vect(n, match._0);
  iteri((function (i, x) {
          return Caml_array.set(a, i, x);
        }), l);
  return a;
}

function to_buffer(buf, g) {
  return iter((function (param) {
                return $$Buffer.add_char(buf, param);
              }), g);
}

function of_string(startOpt, len, s) {
  var start = startOpt !== undefined ? startOpt : 0;
  var len$1;
  if (len !== undefined) {
    if ((len + start | 0) >= s.length) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "OSeq.re",
              1236,
              6
            ],
            Error: new Error()
          };
    }
    len$1 = len;
  } else {
    len$1 = s.length - start | 0;
  }
  var aux = function (i, param) {
    if (i >= (start + len$1 | 0)) {
      return /* Nil */0;
    }
    var x = Caml_string.get(s, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_string(s) {
  var buf = $$Buffer.create(16);
  iter((function (param) {
          return $$Buffer.add_char(buf, param);
        }), s);
  return $$Buffer.contents(buf);
}

function concat_string(sep, s) {
  var match = Curry._1(s, undefined);
  if (!match) {
    return "";
  }
  var sep_len = sep.length;
  var len = fold((function (len, s) {
          return (s.length + sep_len | 0) + len | 0;
        }), match._0.length, match._1);
  var bytes = Bytes.make(len, /* '\000' */0);
  fold((function (off, s) {
          var slen = s.length;
          if ((off + slen | 0) > len) {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "OSeq.re",
                    1281,
                    10
                  ],
                  Error: new Error()
                };
          }
          Caml_bytes.caml_blit_bytes(Bytes.unsafe_of_string(s), 0, bytes, off, slen);
          if ((off + slen | 0) < len) {
            Caml_bytes.caml_blit_bytes(Bytes.unsafe_of_string(sep), 0, bytes, off + slen | 0, sep_len);
            return (off + slen | 0) + sep_len | 0;
          } else {
            return off + slen | 0;
          }
        }), 0, s);
  return Bytes.unsafe_to_string(bytes);
}

function to_iter(_res, k) {
  while(true) {
    var res = _res;
    var match = Curry._1(res, undefined);
    if (!match) {
      return ;
    }
    Curry._1(k, match._0);
    _res = match._1;
    continue ;
  };
}

function to_gen(l) {
  var l$1 = {
    contents: l
  };
  return function (param) {
    var match = Curry._1(l$1.contents, undefined);
    if (match) {
      l$1.contents = match._1;
      return Caml_option.some(match._0);
    }
    
  };
}

function of_gen(g) {
  var consume = function (r, param) {
    var cons = r.contents;
    if (cons.TAG !== /* Of_gen_thunk */0) {
      return cons._0;
    }
    var g = cons._0;
    var x = Curry._1(g, undefined);
    if (x !== undefined) {
      var partial_arg = {
        contents: {
          TAG: /* Of_gen_thunk */0,
          _0: g
        }
      };
      var tl = function (param) {
        return consume(partial_arg, param);
      };
      var l_0 = Caml_option.valFromOption(x);
      var l = /* Cons */{
        _0: l_0,
        _1: tl
      };
      r.contents = {
        TAG: /* Of_gen_saved */1,
        _0: l
      };
      return l;
    }
    r.contents = {
      TAG: /* Of_gen_saved */1,
      _0: /* Nil */0
    };
    return /* Nil */0;
  };
  var partial_arg = {
    contents: {
      TAG: /* Of_gen_thunk */0,
      _0: g
    }
  };
  return function (param) {
    return consume(partial_arg, param);
  };
}

function of_gen_transient(f, param) {
  var x = Curry._1(f, undefined);
  if (x !== undefined) {
    return /* Cons */{
            _0: Caml_option.valFromOption(x),
            _1: (function (param) {
                return of_gen_transient(f, param);
              })
          };
  } else {
    return /* Nil */0;
  }
}

function sort(cmp, l) {
  var l$1 = to_list(l);
  return of_list(List.sort(cmp, l$1));
}

function sort_uniq(cmp, l) {
  var l$1 = to_list(l);
  return uniq((function (x, y) {
                return Curry._2(cmp, x, y) === 0;
              }), of_list(List.sort(cmp, l$1)));
}

function lines(g) {
  var aux = function (_g, buf, _param) {
    while(true) {
      var g = _g;
      var match = Curry._1(g, undefined);
      if (match) {
        var tl = match._1;
        var c = match._0;
        if (c === /* '\n' */10) {
          var s = $$Buffer.contents(buf);
          $$Buffer.clear(buf);
          return /* Cons */{
                  _0: s,
                  _1: (function(tl){
                  return function (param) {
                    return aux(tl, buf, param);
                  }
                  }(tl))
                };
        }
        $$Buffer.add_char(buf, c);
        _param = undefined;
        _g = tl;
        continue ;
      }
      if ($$Buffer.length(buf) === 0) {
        return /* Nil */0;
      }
      var s$1 = $$Buffer.contents(buf);
      $$Buffer.clear(buf);
      return /* Cons */{
              _0: s$1,
              _1: empty
            };
    };
  };
  var partial_arg = $$Buffer.create(16);
  return function (param) {
    return aux(g, partial_arg, param);
  };
}

function unlines(g) {
  var aux = function (g, st, param) {
    if (typeof st === "string") {
      if (st === "Stop") {
        return /* Nil */0;
      }
      var match = Curry._1(g, undefined);
      if (!match) {
        return /* Nil */0;
      }
      var s = match._0;
      if (s === "") {
        var tl = match._1;
        return /* Cons */{
                _0: /* '\n' */10,
                _1: (function (param) {
                    return aux(tl, st, param);
                  })
              };
      }
      var tl$1 = match._1;
      var partial_arg_1 = [
        s,
        1
      ];
      var partial_arg = {
        NAME: "Consume",
        VAL: partial_arg_1
      };
      return /* Cons */{
              _0: Caml_string.get(s, 0),
              _1: (function (param) {
                  return aux(tl$1, partial_arg, param);
                })
            };
    }
    var match$1 = st.VAL;
    var i = match$1[1];
    var s$1 = match$1[0];
    if (i === s$1.length) {
      return /* Cons */{
              _0: /* '\n' */10,
              _1: (function (param) {
                  return aux(g, "Next", param);
                })
            };
    }
    var partial_arg_1$1 = [
      s$1,
      i + 1 | 0
    ];
    var partial_arg$1 = {
      NAME: "Consume",
      VAL: partial_arg_1$1
    };
    return /* Cons */{
            _0: Caml_string.get(s$1, i),
            _1: (function (param) {
                return aux(g, partial_arg$1, param);
              })
          };
  };
  return function (param) {
    return aux(g, "Next", param);
  };
}

function memoize(f) {
  var r = {
    contents: /* MemoThunk */0
  };
  return function (param) {
    var l = r.contents;
    if (l) {
      return l._0;
    }
    var match = Curry._1(f, undefined);
    var l$1 = match ? /* Cons */({
          _0: match._0,
          _1: memoize(match._1)
        }) : /* Nil */0;
    r.contents = /* MemoSave */{
      _0: l$1
    };
    return l$1;
  };
}

function $$yield(x) {
  return {
          TAG: /* Yield */0,
          _0: x
        };
}

function $great$great$eq$1(x, f) {
  return {
          TAG: /* Append */2,
          _0: x,
          _1: {
            TAG: /* Delay */1,
            _0: f
          }
        };
}

function delay(f) {
  return {
          TAG: /* Delay */1,
          _0: f
        };
}

function run(x) {
  var aux = function (_l, _param) {
    while(true) {
      var l = _l;
      if (!l) {
        return /* Nil */0;
      }
      var x = l.hd;
      if (typeof x === "number") {
        _param = undefined;
        _l = l.tl;
        continue ;
      }
      switch (x.TAG | 0) {
        case /* Yield */0 :
            var tl = l.tl;
            return /* Cons */{
                    _0: x._0,
                    _1: (function(tl){
                    return function (param) {
                      return aux(tl, param);
                    }
                    }(tl))
                  };
        case /* Delay */1 :
            _param = undefined;
            _l = {
              hd: Curry._1(x._0, undefined),
              tl: l.tl
            };
            continue ;
        case /* Append */2 :
            _param = undefined;
            _l = {
              hd: x._0,
              tl: {
                hd: x._1,
                tl: l.tl
              }
            };
            continue ;
        
      }
    };
  };
  var partial_arg = {
    hd: x,
    tl: /* [] */0
  };
  return function (param) {
    return aux(partial_arg, param);
  };
}

var Generator = {
  empty: /* Skip */0,
  $$yield: $$yield,
  $great$great$eq: $great$great$eq$1,
  delay: delay,
  run: run
};

function with_file_in(modeOpt, flagsOpt, filename, f) {
  var mode = modeOpt !== undefined ? modeOpt : 420;
  var flags = flagsOpt !== undefined ? flagsOpt : /* [] */0;
  var ic = Pervasives.open_in_gen(flags, mode, filename);
  try {
    var x = Curry._1(f, ic);
    Pervasives.close_in_noerr(ic);
    return x;
  }
  catch (e){
    Pervasives.close_in_noerr(ic);
    throw e;
  }
}

function with_in(mode, flags, filename, f) {
  return with_file_in(mode, flags, filename, (function (ic) {
                return Curry._1(f, of_gen(function (param) {
                                try {
                                  return Pervasives.input_char(ic);
                                }
                                catch (raw_exn){
                                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                  if (exn.RE_EXN_ID === "End_of_file") {
                                    return ;
                                  }
                                  throw exn;
                                }
                              }));
              }));
}

function with_lines(mode, flags, filename, f) {
  return with_file_in(mode, flags, filename, (function (ic) {
                return Curry._1(f, of_gen(function (param) {
                                try {
                                  return Pervasives.input_line(ic);
                                }
                                catch (raw_exn){
                                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                  if (exn.RE_EXN_ID === "End_of_file") {
                                    return ;
                                  }
                                  throw exn;
                                }
                              }));
              }));
}

function with_file_out(modeOpt, flagsOpt, filename, f) {
  var mode = modeOpt !== undefined ? modeOpt : 420;
  var flags = flagsOpt !== undefined ? flagsOpt : ({
        hd: /* Open_creat */3,
        tl: {
          hd: /* Open_wronly */1,
          tl: /* [] */0
        }
      });
  var oc = Pervasives.open_out_gen(flags, mode, filename);
  try {
    var x = Curry._1(f, oc);
    Pervasives.close_out(oc);
    return x;
  }
  catch (e){
    Pervasives.close_out_noerr(oc);
    throw e;
  }
}

function write_str(mode, flags, sepOpt, filename, g) {
  var sep = sepOpt !== undefined ? sepOpt : "";
  return with_file_out(mode, flags, filename, (function (oc) {
                return iteri((function (i, s) {
                              if (i > 0) {
                                Pervasives.output_string(oc, sep);
                              }
                              return Pervasives.output_string(oc, s);
                            }), g);
              }));
}

function write(mode, flags, filename, g) {
  return with_file_out(mode, flags, filename, (function (oc) {
                return iter((function (c) {
                              return Pervasives.output_char(oc, c);
                            }), g);
              }));
}

function write_lines(mode, flags, filename, g) {
  return with_file_out(mode, flags, filename, (function (oc) {
                return iter((function (s) {
                              Pervasives.output_string(oc, s);
                              return Pervasives.output_char(oc, /* '\n' */10);
                            }), g);
              }));
}

function pp(sepOpt, pp_item, fmt, l) {
  var sep = sepOpt !== undefined ? sepOpt : ",";
  var match = Curry._1(l, undefined);
  if (match) {
    Curry._2(pp_item, fmt, match._0);
    var _l = match._1;
    while(true) {
      var l$1 = _l;
      var match$1 = Curry._1(l$1, undefined);
      if (!match$1) {
        return ;
      }
      Format.pp_print_string(fmt, sep);
      Format.pp_print_cut(fmt, undefined);
      Curry._2(pp_item, fmt, match$1._0);
      _l = match$1._1;
      continue ;
    };
  }
  
}

var fold_left = fold;

var Infix = {
  $neg$neg: $neg$neg,
  $neg$neg$caret: $neg$neg$caret,
  $great$great$eq: $great$great$eq,
  $great$great$pipe: $great$great$pipe,
  $great$pipe$eq: $great$pipe$eq,
  $less$star$great: app
};

var $less$star$great = app;

var IO = {
  with_in: with_in,
  with_lines: with_lines,
  write_str: write_str,
  write: write,
  write_lines: write_lines
};

function Traverse(funarg) {
  var map_m = function (f, l) {
    var aux = function (acc, l) {
      var match = Curry._1(l, undefined);
      if (!match) {
        return Curry._1(funarg.$$return, of_list(List.rev(acc)));
      }
      var l$prime = match._1;
      return Curry._2(funarg.$great$great$eq, Curry._1(f, match._0), (function (x$prime) {
                    return aux({
                                hd: x$prime,
                                tl: acc
                              }, l$prime);
                  }));
    };
    return aux(/* [] */0, l);
  };
  var sequence_m = function (l) {
    return map_m((function (x) {
                  return x;
                }), l);
  };
  var fold_m = function (f, acc, l) {
    var match = Curry._1(l, undefined);
    if (!match) {
      return Curry._1(funarg.$$return, acc);
    }
    var l$prime = match._1;
    return Curry._2(funarg.$great$great$eq, Curry._2(f, acc, match._0), (function (acc$prime) {
                  return fold_m(f, acc$prime, l$prime);
                }));
  };
  return {
          sequence_m: sequence_m,
          fold_m: fold_m,
          map_m: map_m
        };
}

exports.empty = empty;
exports.$$return = $$return;
exports.cons = cons;
exports.repeat = repeat;
exports.head_exn = head_exn;
exports.tail_exn = tail_exn;
exports.cycle = cycle;
exports.iterate = iterate;
exports.unfold = unfold;
exports.repeatedly = repeatedly;
exports.init = init;
exports.is_empty = is_empty;
exports.fold = fold;
exports.fold_left = fold_left;
exports.foldi = foldi;
exports.reduce = reduce;
exports.scan = scan;
exports.unfold_scan = unfold_scan;
exports.iter = iter;
exports.iteri = iteri;
exports.length = length;
exports.map = map;
exports.mapi = mapi;
exports.app = app;
exports.fold_map = fold_map;
exports.append = append;
exports.flatten = flatten;
exports.flat_map = flat_map;
exports.app_interleave = app_interleave;
exports.flat_map_interleave = flat_map_interleave;
exports.mem = mem;
exports.take = take;
exports.drop = drop;
exports.nth = nth;
exports.take_nth = take_nth;
exports.filter = filter;
exports.take_while = take_while;
exports.fold_while = fold_while;
exports.drop_while = drop_while;
exports.filter_map = filter_map;
exports.zip_index = zip_index;
exports.unzip = unzip;
exports.partition = partition;
exports.for_all = for_all;
exports.exists = exists;
exports.min = min;
exports.max = max;
exports.equal = equal;
exports.compare = compare;
exports.find = find;
exports.find_map = find_map;
exports.sum = sum;
exports.map2 = map2;
exports.iter2 = iter2;
exports.fold2 = fold2;
exports.for_all2 = for_all2;
exports.exists2 = exists2;
exports.zip_with = zip_with;
exports.zip = zip;
exports.merge = merge;
exports.intersection = intersection;
exports.sorted_merge = sorted_merge;
exports.round_robin = round_robin;
exports.interleave = interleave;
exports.intersperse = intersperse;
exports.product = product;
exports.product3 = product3;
exports.product4 = product4;
exports.product5 = product5;
exports.product6 = product6;
exports.product7 = product7;
exports.cartesian_product = cartesian_product;
exports.map_product_l = map_product_l;
exports.group = group;
exports.uniq = uniq;
exports.sort = sort;
exports.sort_uniq = sort_uniq;
exports.chunks = chunks;
exports.permutations = permutations;
exports.combinations = combinations;
exports.power_set = power_set;
exports.of_list = of_list;
exports.to_list = to_list;
exports.to_rev_list = to_rev_list;
exports.to_array = to_array;
exports.of_array = of_array;
exports.of_gen = of_gen;
exports.of_gen_transient = of_gen_transient;
exports.to_gen = to_gen;
exports.of_string = of_string;
exports.to_string = to_string;
exports.to_buffer = to_buffer;
exports.to_iter = to_iter;
exports.concat_string = concat_string;
exports.lines = lines;
exports.unlines = unlines;
exports.Infix = Infix;
exports.$neg$neg = $neg$neg;
exports.$neg$neg$caret = $neg$neg$caret;
exports.$great$great$eq = $great$great$eq;
exports.$great$great$pipe = $great$great$pipe;
exports.$great$pipe$eq = $great$pipe$eq;
exports.$less$star$great = $less$star$great;
exports.pp = pp;
exports.memoize = memoize;
exports.Generator = Generator;
exports.IO = IO;
exports.Traverse = Traverse;
/* Format Not a pure module */
